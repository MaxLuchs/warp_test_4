# Warp

## warp-and
- and-argument: Takes a Filter-Struct as argument (which is a struct & not a function like the warp-map or warp-and_then expects)
- the argument-Filter can generate another parameter
```
warp::any().and(
    warp::any().map(|| "Was geht")
)
```


## warp-map
- map-argument: Takes a function which receives arguments from previous Filters & returns another value
- map-return-value: Reply + Rejection + any other generated value which will can get passed to another warp-map
```
use warp::Filter;

let test = warp::get()
    .map(|| "Hallo".to_owned())
    .map(|text: String| format!("{} da dr√ºben", text))
    .map(|text: String| warp::reply::with_status(text, warp::http::StatusCode::OK));
```

# warp-and_then
- and_then-argument: receives arguments generated by warp-and & consumes them but can gene
- and_then-return-value: Future-Result which will get unwrapped

# Difference between warp-map & warp-and & warp-and_then
- warp-map expects a function whose Return-value will be piped into the subsequent warp-map.
```
warp::any()
    .map(|| "Hallo".to_owned())
    .map(|name: String| format!("{}, du Schlumpf"))
```
- warp-and expects a Filter-Struct. if the Filter-struct performs a warp-map, the return value of warp-map-function will get as an additional argument passed into the subsequent warp-map.
```
warp::any()
    .and(warp::map(|| "Hallo".to_owned()))
    .and(warp::map(|| format!("du Schlumpf")))
    .map(|greet, name| format!("{}, {}", greet, name))
```  

- warp-and_then expects a function with Return-value of Result<ANY, warp::reject::Rejection>
```
warp::any()
    .and(warp::map(|| "Hallo".to_owned()))
    .and_then(|greet: String| async move {
        Ok::<Result<String, Infallible>>(format!("{}, du Schlumpf", greet)))
    }))
```  

# Error-Handling in warp

